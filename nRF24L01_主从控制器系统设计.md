# nRF24L01 主从控制器系统设计

## 🏗️ **系统架构**

### 1. **网络拓扑结构**

```
主控制器 (Master)
├── 备用控制器1 (Backup1)
├── 备用控制器2 (Backup2)
├── 无线控制盒1 (ControlBox1)
├── 无线控制盒2 (ControlBox2)
└── 其他设备... (可动态添加)
```

### 2. **设备类型定义**

```cpp
// 设备类型
enum DeviceType {
  DEVICE_MASTER = 0x01,      // 主控制器
  DEVICE_BACKUP = 0x02,      // 备用控制器
  DEVICE_CONTROL_BOX = 0x03, // 无线控制盒
  DEVICE_SENSOR = 0x04,      // 传感器
  DEVICE_ACTUATOR = 0x05     // 执行器
};

// 设备状态
enum DeviceStatus {
  STATUS_OFFLINE = 0x00,     // 离线
  STATUS_ONLINE = 0x01,      // 在线
  STATUS_ACTIVE = 0x02,      // 活跃
  STATUS_STANDBY = 0x03,     // 待机
  STATUS_ERROR = 0x04        // 错误
};
```

## 🔧 **设备管理机制**

### 1. **设备注册表**

```cpp
// 设备信息结构
struct DeviceInfo {
  uint8_t deviceId;          // 设备ID
  uint8_t deviceType;        // 设备类型
  uint8_t status;            // 设备状态
  uint32_t lastSeen;         // 最后通信时间
  uint8_t signalStrength;    // 信号强度
  bool isActive;             // 是否活跃
};

// 设备管理类
class DeviceManager {
private:
  DeviceInfo devices[MAX_DEVICES];  // 最大支持设备数
  uint8_t deviceCount;
  uint8_t activeMasterId;
  
public:
  DeviceManager();
  
  // 设备注册
  bool registerDevice(uint8_t deviceId, uint8_t deviceType);
  
  // 设备注销
  bool unregisterDevice(uint8_t deviceId);
  
  // 更新设备状态
  void updateDeviceStatus(uint8_t deviceId, uint8_t status);
  
  // 获取活跃主控制器
  uint8_t getActiveMaster();
  
  // 设置备用控制器
  bool setBackupMaster(uint8_t deviceId);
  
  // 获取设备列表
  void getDeviceList(DeviceInfo* list, uint8_t* count);
};
```

### 2. **动态设备发现**

```cpp
// 设备发现协议
struct DiscoveryPacket {
  uint8_t header[4];         // 包头: 0xAA, 0x55, 0xAA, 0x55
  uint8_t packetType;        // 包类型: 0x01=发现请求, 0x02=发现响应
  uint8_t deviceId;          // 设备ID
  uint8_t deviceType;        // 设备类型
  uint8_t capabilities;      // 设备能力
  uint8_t checksum;          // 校验和
  uint8_t footer[2];         // 包尾: 0x55, 0xAA
};

// 设备发现功能
void startDeviceDiscovery() {
  Serial.println("开始设备发现...");
  
  DiscoveryPacket discovery;
  discovery.header[0] = 0xAA;
  discovery.header[1] = 0x55;
  discovery.header[2] = 0xAA;
  discovery.header[3] = 0x55;
  discovery.packetType = 0x01;  // 发现请求
  discovery.deviceId = MY_DEVICE_ID;
  discovery.deviceType = DEVICE_MASTER;
  discovery.capabilities = 0xFF;  // 所有能力
  discovery.checksum = calculateChecksum(&discovery);
  discovery.footer[0] = 0x55;
  discovery.footer[1] = 0xAA;
  
  // 广播发现请求
  radio.stopListening();
  radio.write(&discovery, sizeof(discovery));
  radio.startListening();
  
  Serial.println("设备发现请求已发送");
}
```

## 📡 **通信协议设计**

### 1. **多设备通信协议**

```cpp
// 通信数据包结构
struct CommunicationPacket {
  uint8_t header[4];         // 包头
  uint8_t packetType;        // 包类型
  uint8_t sourceId;          // 源设备ID
  uint8_t targetId;          // 目标设备ID (0xFF=广播)
  uint8_t command;           // 命令
  uint8_t data[20];          // 数据
  uint8_t checksum;          // 校验和
  uint8_t footer[2];         // 包尾
};

// 包类型定义
enum PacketType {
  PACKET_HEARTBEAT = 0x01,   // 心跳包
  PACKET_COMMAND = 0x02,     // 命令包
  PACKET_RESPONSE = 0x03,    // 响应包
  PACKET_DISCOVERY = 0x04,   // 发现包
  PACKET_STATUS = 0x05,      // 状态包
  PACKET_EMERGENCY = 0x06    // 紧急包
};
```

### 2. **地址管理**

```cpp
// 地址配置
const byte BROADCAST_ADDRESS[6] = "BCAST";  // 广播地址
const byte MASTER_ADDRESS[6] = "MASTR";     // 主控制器地址
const byte BACKUP_ADDRESS[6] = "BACKP";     // 备用控制器地址
const byte CONTROL_BOX_ADDRESS[6] = "CTRLB"; // 控制盒地址

// 动态地址生成
void generateDeviceAddress(uint8_t deviceId, byte* address) {
  address[0] = 'D';
  address[1] = 'E';
  address[2] = 'V';
  address[3] = (deviceId >> 4) & 0x0F;
  address[4] = deviceId & 0x0F;
  address[5] = '\0';
}

// 设置接收管道
void setupReceivePipes() {
  // 管道0: 广播地址
  radio.openReadingPipe(0, BROADCAST_ADDRESS);
  
  // 管道1: 设备专用地址
  byte deviceAddress[6];
  generateDeviceAddress(MY_DEVICE_ID, deviceAddress);
  radio.openReadingPipe(1, deviceAddress);
  
  // 管道2-5: 其他设备地址（根据需要动态设置）
  for (int i = 2; i < 6; i++) {
    radio.openReadingPipe(i, BROADCAST_ADDRESS);
  }
}
```

## 🔄 **主从切换机制**

### 1. **主控制器选举**

```cpp
// 主控制器选举算法
uint8_t electMaster() {
  uint8_t candidateId = 0;
  uint8_t highestPriority = 0;
  
  for (int i = 0; i < deviceCount; i++) {
    if (devices[i].deviceType == DEVICE_MASTER || 
        devices[i].deviceType == DEVICE_BACKUP) {
      
      uint8_t priority = calculatePriority(devices[i]);
      if (priority > highestPriority) {
        highestPriority = priority;
        candidateId = devices[i].deviceId;
      }
    }
  }
  
  return candidateId;
}

// 优先级计算
uint8_t calculatePriority(DeviceInfo device) {
  uint8_t priority = 0;
  
  // 设备类型优先级
  if (device.deviceType == DEVICE_MASTER) priority += 100;
  else if (device.deviceType == DEVICE_BACKUP) priority += 50;
  
  // 信号强度
  priority += device.signalStrength;
  
  // 在线时间
  priority += (millis() - device.lastSeen) / 1000;
  
  return priority;
}
```

### 2. **故障检测和切换**

```cpp
// 故障检测
void checkMasterHealth() {
  static unsigned long lastCheck = 0;
  
  if (millis() - lastCheck > 5000) {  // 每5秒检查一次
    lastCheck = millis();
    
    // 检查主控制器是否在线
    if (activeMasterId != 0) {
      DeviceInfo* master = findDevice(activeMasterId);
      if (master && (millis() - master->lastSeen > 10000)) {
        Serial.println("主控制器离线，开始切换...");
        switchToBackup();
      }
    }
  }
}

// 切换到备用控制器
void switchToBackup() {
  uint8_t newMaster = electMaster();
  
  if (newMaster != 0 && newMaster != activeMasterId) {
    Serial.print("切换到备用控制器: ");
    Serial.println(newMaster);
    
    // 发送切换通知
    sendMasterSwitchNotification(newMaster);
    
    // 更新活跃主控制器
    activeMasterId = newMaster;
    
    // 更新设备状态
    updateDeviceStatus(newMaster, STATUS_ACTIVE);
  }
}
```

## 🚀 **实际实现示例**

### 1. **主控制器代码**

```cpp
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>

RF24 radio(7, 8); // CE, CSN
DeviceManager deviceManager;

void setup() {
  Serial.begin(115200);
  
  // 初始化nRF24L01
  radio.begin();
  radio.setChannel(76);
  radio.setDataRate(RF24_1MBPS);
  radio.setPALevel(RF24_PA_HIGH);
  radio.setRetries(15, 15);
  
  // 设置接收管道
  setupReceivePipes();
  
  // 开始监听
  radio.startListening();
  
  // 注册自己为主控制器
  deviceManager.registerDevice(MY_DEVICE_ID, DEVICE_MASTER);
  deviceManager.setActiveMaster(MY_DEVICE_ID);
  
  Serial.println("主控制器初始化完成");
  
  // 开始设备发现
  startDeviceDiscovery();
}

void loop() {
  // 检查接收数据
  if (radio.available()) {
    CommunicationPacket packet;
    radio.read(&packet, sizeof(packet));
    processPacket(&packet);
  }
  
  // 发送心跳
  if (millis() - lastHeartbeatTime > 1000) {
    sendHeartbeat();
    lastHeartbeatTime = millis();
  }
  
  // 检查主控制器健康状态
  checkMasterHealth();
  
  // 设备管理
  deviceManager.updateDeviceList();
}
```

### 2. **备用控制器代码**

```cpp
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>

RF24 radio(7, 8); // CE, CSN
DeviceManager deviceManager;

void setup() {
  Serial.begin(115200);
  
  // 初始化nRF24L01
  radio.begin();
  radio.setChannel(76);
  radio.setDataRate(RF24_1MBPS);
  radio.setPALevel(RF24_PA_HIGH);
  radio.setRetries(15, 15);
  
  // 设置接收管道
  setupReceivePipes();
  
  // 开始监听
  radio.startListening();
  
  // 注册自己为备用控制器
  deviceManager.registerDevice(MY_DEVICE_ID, DEVICE_BACKUP);
  
  Serial.println("备用控制器初始化完成");
  
  // 发送设备发现响应
  sendDiscoveryResponse();
}

void loop() {
  // 检查接收数据
  if (radio.available()) {
    CommunicationPacket packet;
    radio.read(&packet, sizeof(packet));
    processPacket(&packet);
  }
  
  // 发送心跳
  if (millis() - lastHeartbeatTime > 1000) {
    sendHeartbeat();
    lastHeartbeatTime = millis();
  }
  
  // 检查是否需要接管主控制器
  checkMasterTakeover();
}
```

### 3. **无线控制盒代码**

```cpp
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>

RF24 radio(7, 8); // CE, CSN
DeviceManager deviceManager;

void setup() {
  Serial.begin(115200);
  
  // 初始化nRF24L01
  radio.begin();
  radio.setChannel(76);
  radio.setDataRate(RF24_1MBPS);
  radio.setPALevel(RF24_PA_HIGH);
  radio.setRetries(15, 15);
  
  // 设置接收管道
  setupReceivePipes();
  
  // 开始监听
  radio.startListening();
  
  // 注册自己为控制盒
  deviceManager.registerDevice(MY_DEVICE_ID, DEVICE_CONTROL_BOX);
  
  Serial.println("无线控制盒初始化完成");
  
  // 发送设备发现响应
  sendDiscoveryResponse();
}

void loop() {
  // 检查接收数据
  if (radio.available()) {
    CommunicationPacket packet;
    radio.read(&packet, sizeof(packet));
    processPacket(&packet);
  }
  
  // 检查按钮状态
  checkButtonStates();
  
  // 发送控制命令
  if (buttonPressed) {
    sendControlCommand();
  }
}
```

## 🎯 **系统特性**

### 1. **动态设备管理**
- ✅ 自动发现新设备
- ✅ 动态注册和注销
- ✅ 设备状态监控
- ✅ 信号强度检测

### 2. **主从切换**
- ✅ 自动故障检测
- ✅ 智能主控制器选举
- ✅ 无缝切换
- ✅ 状态同步

### 3. **扩展性**
- ✅ 支持最多6个设备
- ✅ 可动态添加设备
- ✅ 支持多种设备类型
- ✅ 灵活的通信协议

### 4. **可靠性**
- ✅ 自动重传机制
- ✅ 错误检测和纠正
- ✅ 心跳监控
- ✅ 故障恢复

---

**总结**: nRF24L01完全支持主从控制器系统，并且可以轻松添加备用控制器。通过合理的协议设计和设备管理机制，可以实现一个稳定、可靠、可扩展的多设备控制系统。

