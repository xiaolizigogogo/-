# nRF24L01 ä¸»ä»æ§åˆ¶å™¨ç³»ç»Ÿè®¾è®¡

## ğŸ—ï¸ **ç³»ç»Ÿæ¶æ„**

### 1. **ç½‘ç»œæ‹“æ‰‘ç»“æ„**

```
ä¸»æ§åˆ¶å™¨ (Master)
â”œâ”€â”€ å¤‡ç”¨æ§åˆ¶å™¨1 (Backup1)
â”œâ”€â”€ å¤‡ç”¨æ§åˆ¶å™¨2 (Backup2)
â”œâ”€â”€ æ— çº¿æ§åˆ¶ç›’1 (ControlBox1)
â”œâ”€â”€ æ— çº¿æ§åˆ¶ç›’2 (ControlBox2)
â””â”€â”€ å…¶ä»–è®¾å¤‡... (å¯åŠ¨æ€æ·»åŠ )
```

### 2. **è®¾å¤‡ç±»å‹å®šä¹‰**

```cpp
// è®¾å¤‡ç±»å‹
enum DeviceType {
  DEVICE_MASTER = 0x01,      // ä¸»æ§åˆ¶å™¨
  DEVICE_BACKUP = 0x02,      // å¤‡ç”¨æ§åˆ¶å™¨
  DEVICE_CONTROL_BOX = 0x03, // æ— çº¿æ§åˆ¶ç›’
  DEVICE_SENSOR = 0x04,      // ä¼ æ„Ÿå™¨
  DEVICE_ACTUATOR = 0x05     // æ‰§è¡Œå™¨
};

// è®¾å¤‡çŠ¶æ€
enum DeviceStatus {
  STATUS_OFFLINE = 0x00,     // ç¦»çº¿
  STATUS_ONLINE = 0x01,      // åœ¨çº¿
  STATUS_ACTIVE = 0x02,      // æ´»è·ƒ
  STATUS_STANDBY = 0x03,     // å¾…æœº
  STATUS_ERROR = 0x04        // é”™è¯¯
};
```

## ğŸ”§ **è®¾å¤‡ç®¡ç†æœºåˆ¶**

### 1. **è®¾å¤‡æ³¨å†Œè¡¨**

```cpp
// è®¾å¤‡ä¿¡æ¯ç»“æ„
struct DeviceInfo {
  uint8_t deviceId;          // è®¾å¤‡ID
  uint8_t deviceType;        // è®¾å¤‡ç±»å‹
  uint8_t status;            // è®¾å¤‡çŠ¶æ€
  uint32_t lastSeen;         // æœ€åé€šä¿¡æ—¶é—´
  uint8_t signalStrength;    // ä¿¡å·å¼ºåº¦
  bool isActive;             // æ˜¯å¦æ´»è·ƒ
};

// è®¾å¤‡ç®¡ç†ç±»
class DeviceManager {
private:
  DeviceInfo devices[MAX_DEVICES];  // æœ€å¤§æ”¯æŒè®¾å¤‡æ•°
  uint8_t deviceCount;
  uint8_t activeMasterId;
  
public:
  DeviceManager();
  
  // è®¾å¤‡æ³¨å†Œ
  bool registerDevice(uint8_t deviceId, uint8_t deviceType);
  
  // è®¾å¤‡æ³¨é”€
  bool unregisterDevice(uint8_t deviceId);
  
  // æ›´æ–°è®¾å¤‡çŠ¶æ€
  void updateDeviceStatus(uint8_t deviceId, uint8_t status);
  
  // è·å–æ´»è·ƒä¸»æ§åˆ¶å™¨
  uint8_t getActiveMaster();
  
  // è®¾ç½®å¤‡ç”¨æ§åˆ¶å™¨
  bool setBackupMaster(uint8_t deviceId);
  
  // è·å–è®¾å¤‡åˆ—è¡¨
  void getDeviceList(DeviceInfo* list, uint8_t* count);
};
```

### 2. **åŠ¨æ€è®¾å¤‡å‘ç°**

```cpp
// è®¾å¤‡å‘ç°åè®®
struct DiscoveryPacket {
  uint8_t header[4];         // åŒ…å¤´: 0xAA, 0x55, 0xAA, 0x55
  uint8_t packetType;        // åŒ…ç±»å‹: 0x01=å‘ç°è¯·æ±‚, 0x02=å‘ç°å“åº”
  uint8_t deviceId;          // è®¾å¤‡ID
  uint8_t deviceType;        // è®¾å¤‡ç±»å‹
  uint8_t capabilities;      // è®¾å¤‡èƒ½åŠ›
  uint8_t checksum;          // æ ¡éªŒå’Œ
  uint8_t footer[2];         // åŒ…å°¾: 0x55, 0xAA
};

// è®¾å¤‡å‘ç°åŠŸèƒ½
void startDeviceDiscovery() {
  Serial.println("å¼€å§‹è®¾å¤‡å‘ç°...");
  
  DiscoveryPacket discovery;
  discovery.header[0] = 0xAA;
  discovery.header[1] = 0x55;
  discovery.header[2] = 0xAA;
  discovery.header[3] = 0x55;
  discovery.packetType = 0x01;  // å‘ç°è¯·æ±‚
  discovery.deviceId = MY_DEVICE_ID;
  discovery.deviceType = DEVICE_MASTER;
  discovery.capabilities = 0xFF;  // æ‰€æœ‰èƒ½åŠ›
  discovery.checksum = calculateChecksum(&discovery);
  discovery.footer[0] = 0x55;
  discovery.footer[1] = 0xAA;
  
  // å¹¿æ’­å‘ç°è¯·æ±‚
  radio.stopListening();
  radio.write(&discovery, sizeof(discovery));
  radio.startListening();
  
  Serial.println("è®¾å¤‡å‘ç°è¯·æ±‚å·²å‘é€");
}
```

## ğŸ“¡ **é€šä¿¡åè®®è®¾è®¡**

### 1. **å¤šè®¾å¤‡é€šä¿¡åè®®**

```cpp
// é€šä¿¡æ•°æ®åŒ…ç»“æ„
struct CommunicationPacket {
  uint8_t header[4];         // åŒ…å¤´
  uint8_t packetType;        // åŒ…ç±»å‹
  uint8_t sourceId;          // æºè®¾å¤‡ID
  uint8_t targetId;          // ç›®æ ‡è®¾å¤‡ID (0xFF=å¹¿æ’­)
  uint8_t command;           // å‘½ä»¤
  uint8_t data[20];          // æ•°æ®
  uint8_t checksum;          // æ ¡éªŒå’Œ
  uint8_t footer[2];         // åŒ…å°¾
};

// åŒ…ç±»å‹å®šä¹‰
enum PacketType {
  PACKET_HEARTBEAT = 0x01,   // å¿ƒè·³åŒ…
  PACKET_COMMAND = 0x02,     // å‘½ä»¤åŒ…
  PACKET_RESPONSE = 0x03,    // å“åº”åŒ…
  PACKET_DISCOVERY = 0x04,   // å‘ç°åŒ…
  PACKET_STATUS = 0x05,      // çŠ¶æ€åŒ…
  PACKET_EMERGENCY = 0x06    // ç´§æ€¥åŒ…
};
```

### 2. **åœ°å€ç®¡ç†**

```cpp
// åœ°å€é…ç½®
const byte BROADCAST_ADDRESS[6] = "BCAST";  // å¹¿æ’­åœ°å€
const byte MASTER_ADDRESS[6] = "MASTR";     // ä¸»æ§åˆ¶å™¨åœ°å€
const byte BACKUP_ADDRESS[6] = "BACKP";     // å¤‡ç”¨æ§åˆ¶å™¨åœ°å€
const byte CONTROL_BOX_ADDRESS[6] = "CTRLB"; // æ§åˆ¶ç›’åœ°å€

// åŠ¨æ€åœ°å€ç”Ÿæˆ
void generateDeviceAddress(uint8_t deviceId, byte* address) {
  address[0] = 'D';
  address[1] = 'E';
  address[2] = 'V';
  address[3] = (deviceId >> 4) & 0x0F;
  address[4] = deviceId & 0x0F;
  address[5] = '\0';
}

// è®¾ç½®æ¥æ”¶ç®¡é“
void setupReceivePipes() {
  // ç®¡é“0: å¹¿æ’­åœ°å€
  radio.openReadingPipe(0, BROADCAST_ADDRESS);
  
  // ç®¡é“1: è®¾å¤‡ä¸“ç”¨åœ°å€
  byte deviceAddress[6];
  generateDeviceAddress(MY_DEVICE_ID, deviceAddress);
  radio.openReadingPipe(1, deviceAddress);
  
  // ç®¡é“2-5: å…¶ä»–è®¾å¤‡åœ°å€ï¼ˆæ ¹æ®éœ€è¦åŠ¨æ€è®¾ç½®ï¼‰
  for (int i = 2; i < 6; i++) {
    radio.openReadingPipe(i, BROADCAST_ADDRESS);
  }
}
```

## ğŸ”„ **ä¸»ä»åˆ‡æ¢æœºåˆ¶**

### 1. **ä¸»æ§åˆ¶å™¨é€‰ä¸¾**

```cpp
// ä¸»æ§åˆ¶å™¨é€‰ä¸¾ç®—æ³•
uint8_t electMaster() {
  uint8_t candidateId = 0;
  uint8_t highestPriority = 0;
  
  for (int i = 0; i < deviceCount; i++) {
    if (devices[i].deviceType == DEVICE_MASTER || 
        devices[i].deviceType == DEVICE_BACKUP) {
      
      uint8_t priority = calculatePriority(devices[i]);
      if (priority > highestPriority) {
        highestPriority = priority;
        candidateId = devices[i].deviceId;
      }
    }
  }
  
  return candidateId;
}

// ä¼˜å…ˆçº§è®¡ç®—
uint8_t calculatePriority(DeviceInfo device) {
  uint8_t priority = 0;
  
  // è®¾å¤‡ç±»å‹ä¼˜å…ˆçº§
  if (device.deviceType == DEVICE_MASTER) priority += 100;
  else if (device.deviceType == DEVICE_BACKUP) priority += 50;
  
  // ä¿¡å·å¼ºåº¦
  priority += device.signalStrength;
  
  // åœ¨çº¿æ—¶é—´
  priority += (millis() - device.lastSeen) / 1000;
  
  return priority;
}
```

### 2. **æ•…éšœæ£€æµ‹å’Œåˆ‡æ¢**

```cpp
// æ•…éšœæ£€æµ‹
void checkMasterHealth() {
  static unsigned long lastCheck = 0;
  
  if (millis() - lastCheck > 5000) {  // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
    lastCheck = millis();
    
    // æ£€æŸ¥ä¸»æ§åˆ¶å™¨æ˜¯å¦åœ¨çº¿
    if (activeMasterId != 0) {
      DeviceInfo* master = findDevice(activeMasterId);
      if (master && (millis() - master->lastSeen > 10000)) {
        Serial.println("ä¸»æ§åˆ¶å™¨ç¦»çº¿ï¼Œå¼€å§‹åˆ‡æ¢...");
        switchToBackup();
      }
    }
  }
}

// åˆ‡æ¢åˆ°å¤‡ç”¨æ§åˆ¶å™¨
void switchToBackup() {
  uint8_t newMaster = electMaster();
  
  if (newMaster != 0 && newMaster != activeMasterId) {
    Serial.print("åˆ‡æ¢åˆ°å¤‡ç”¨æ§åˆ¶å™¨: ");
    Serial.println(newMaster);
    
    // å‘é€åˆ‡æ¢é€šçŸ¥
    sendMasterSwitchNotification(newMaster);
    
    // æ›´æ–°æ´»è·ƒä¸»æ§åˆ¶å™¨
    activeMasterId = newMaster;
    
    // æ›´æ–°è®¾å¤‡çŠ¶æ€
    updateDeviceStatus(newMaster, STATUS_ACTIVE);
  }
}
```

## ğŸš€ **å®é™…å®ç°ç¤ºä¾‹**

### 1. **ä¸»æ§åˆ¶å™¨ä»£ç **

```cpp
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>

RF24 radio(7, 8); // CE, CSN
DeviceManager deviceManager;

void setup() {
  Serial.begin(115200);
  
  // åˆå§‹åŒ–nRF24L01
  radio.begin();
  radio.setChannel(76);
  radio.setDataRate(RF24_1MBPS);
  radio.setPALevel(RF24_PA_HIGH);
  radio.setRetries(15, 15);
  
  // è®¾ç½®æ¥æ”¶ç®¡é“
  setupReceivePipes();
  
  // å¼€å§‹ç›‘å¬
  radio.startListening();
  
  // æ³¨å†Œè‡ªå·±ä¸ºä¸»æ§åˆ¶å™¨
  deviceManager.registerDevice(MY_DEVICE_ID, DEVICE_MASTER);
  deviceManager.setActiveMaster(MY_DEVICE_ID);
  
  Serial.println("ä¸»æ§åˆ¶å™¨åˆå§‹åŒ–å®Œæˆ");
  
  // å¼€å§‹è®¾å¤‡å‘ç°
  startDeviceDiscovery();
}

void loop() {
  // æ£€æŸ¥æ¥æ”¶æ•°æ®
  if (radio.available()) {
    CommunicationPacket packet;
    radio.read(&packet, sizeof(packet));
    processPacket(&packet);
  }
  
  // å‘é€å¿ƒè·³
  if (millis() - lastHeartbeatTime > 1000) {
    sendHeartbeat();
    lastHeartbeatTime = millis();
  }
  
  // æ£€æŸ¥ä¸»æ§åˆ¶å™¨å¥åº·çŠ¶æ€
  checkMasterHealth();
  
  // è®¾å¤‡ç®¡ç†
  deviceManager.updateDeviceList();
}
```

### 2. **å¤‡ç”¨æ§åˆ¶å™¨ä»£ç **

```cpp
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>

RF24 radio(7, 8); // CE, CSN
DeviceManager deviceManager;

void setup() {
  Serial.begin(115200);
  
  // åˆå§‹åŒ–nRF24L01
  radio.begin();
  radio.setChannel(76);
  radio.setDataRate(RF24_1MBPS);
  radio.setPALevel(RF24_PA_HIGH);
  radio.setRetries(15, 15);
  
  // è®¾ç½®æ¥æ”¶ç®¡é“
  setupReceivePipes();
  
  // å¼€å§‹ç›‘å¬
  radio.startListening();
  
  // æ³¨å†Œè‡ªå·±ä¸ºå¤‡ç”¨æ§åˆ¶å™¨
  deviceManager.registerDevice(MY_DEVICE_ID, DEVICE_BACKUP);
  
  Serial.println("å¤‡ç”¨æ§åˆ¶å™¨åˆå§‹åŒ–å®Œæˆ");
  
  // å‘é€è®¾å¤‡å‘ç°å“åº”
  sendDiscoveryResponse();
}

void loop() {
  // æ£€æŸ¥æ¥æ”¶æ•°æ®
  if (radio.available()) {
    CommunicationPacket packet;
    radio.read(&packet, sizeof(packet));
    processPacket(&packet);
  }
  
  // å‘é€å¿ƒè·³
  if (millis() - lastHeartbeatTime > 1000) {
    sendHeartbeat();
    lastHeartbeatTime = millis();
  }
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦æ¥ç®¡ä¸»æ§åˆ¶å™¨
  checkMasterTakeover();
}
```

### 3. **æ— çº¿æ§åˆ¶ç›’ä»£ç **

```cpp
#include <SPI.h>
#include <nRF24L01.h>
#include <RF24.h>

RF24 radio(7, 8); // CE, CSN
DeviceManager deviceManager;

void setup() {
  Serial.begin(115200);
  
  // åˆå§‹åŒ–nRF24L01
  radio.begin();
  radio.setChannel(76);
  radio.setDataRate(RF24_1MBPS);
  radio.setPALevel(RF24_PA_HIGH);
  radio.setRetries(15, 15);
  
  // è®¾ç½®æ¥æ”¶ç®¡é“
  setupReceivePipes();
  
  // å¼€å§‹ç›‘å¬
  radio.startListening();
  
  // æ³¨å†Œè‡ªå·±ä¸ºæ§åˆ¶ç›’
  deviceManager.registerDevice(MY_DEVICE_ID, DEVICE_CONTROL_BOX);
  
  Serial.println("æ— çº¿æ§åˆ¶ç›’åˆå§‹åŒ–å®Œæˆ");
  
  // å‘é€è®¾å¤‡å‘ç°å“åº”
  sendDiscoveryResponse();
}

void loop() {
  // æ£€æŸ¥æ¥æ”¶æ•°æ®
  if (radio.available()) {
    CommunicationPacket packet;
    radio.read(&packet, sizeof(packet));
    processPacket(&packet);
  }
  
  // æ£€æŸ¥æŒ‰é’®çŠ¶æ€
  checkButtonStates();
  
  // å‘é€æ§åˆ¶å‘½ä»¤
  if (buttonPressed) {
    sendControlCommand();
  }
}
```

## ğŸ¯ **ç³»ç»Ÿç‰¹æ€§**

### 1. **åŠ¨æ€è®¾å¤‡ç®¡ç†**
- âœ… è‡ªåŠ¨å‘ç°æ–°è®¾å¤‡
- âœ… åŠ¨æ€æ³¨å†Œå’Œæ³¨é”€
- âœ… è®¾å¤‡çŠ¶æ€ç›‘æ§
- âœ… ä¿¡å·å¼ºåº¦æ£€æµ‹

### 2. **ä¸»ä»åˆ‡æ¢**
- âœ… è‡ªåŠ¨æ•…éšœæ£€æµ‹
- âœ… æ™ºèƒ½ä¸»æ§åˆ¶å™¨é€‰ä¸¾
- âœ… æ— ç¼åˆ‡æ¢
- âœ… çŠ¶æ€åŒæ­¥

### 3. **æ‰©å±•æ€§**
- âœ… æ”¯æŒæœ€å¤š6ä¸ªè®¾å¤‡
- âœ… å¯åŠ¨æ€æ·»åŠ è®¾å¤‡
- âœ… æ”¯æŒå¤šç§è®¾å¤‡ç±»å‹
- âœ… çµæ´»çš„é€šä¿¡åè®®

### 4. **å¯é æ€§**
- âœ… è‡ªåŠ¨é‡ä¼ æœºåˆ¶
- âœ… é”™è¯¯æ£€æµ‹å’Œçº æ­£
- âœ… å¿ƒè·³ç›‘æ§
- âœ… æ•…éšœæ¢å¤

---

**æ€»ç»“**: nRF24L01å®Œå…¨æ”¯æŒä¸»ä»æ§åˆ¶å™¨ç³»ç»Ÿï¼Œå¹¶ä¸”å¯ä»¥è½»æ¾æ·»åŠ å¤‡ç”¨æ§åˆ¶å™¨ã€‚é€šè¿‡åˆç†çš„åè®®è®¾è®¡å’Œè®¾å¤‡ç®¡ç†æœºåˆ¶ï¼Œå¯ä»¥å®ç°ä¸€ä¸ªç¨³å®šã€å¯é ã€å¯æ‰©å±•çš„å¤šè®¾å¤‡æ§åˆ¶ç³»ç»Ÿã€‚

