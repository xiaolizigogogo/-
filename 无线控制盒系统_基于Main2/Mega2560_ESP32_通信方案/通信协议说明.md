# Mega2560 + ESP32 通信协议说明

## 协议概述

本系统使用JSON格式进行数据交换，支持多种消息类型和响应机制。所有通信都基于串口进行，波特率为115200。

## 消息类型

### 1. 控制命令 (control)
用于主控制器向从控制器发送控制指令。

#### 发送格式
```json
{
  "type": "control",
  "target": "relay",
  "value": 1,
  "timestamp": 1234567890,
  "source": "master"
}
```

#### 字段说明
- `type`: 消息类型，固定为"control"
- `target`: 控制目标，支持"relay"、"led"、"motor"、"sensor"
- `value`: 控制值，数字类型
- `timestamp`: 时间戳，毫秒
- `source`: 消息来源，固定为"master"

#### 响应格式
```json
{
  "type": "control_response",
  "target": "relay",
  "value": 1,
  "success": true,
  "timestamp": 1234567890,
  "source": "slave",
  "execution_count": 15
}
```

### 2. 状态请求 (status_request)
用于主控制器查询从控制器状态。

#### 发送格式
```json
{
  "type": "status_request",
  "timestamp": 1234567890,
  "source": "master"
}
```

#### 响应格式
```json
{
  "type": "status_response",
  "system_ready": true,
  "execution_count": 15,
  "last_command": "relay",
  "last_command_time": 1234567890,
  "sensor_value": 512,
  "uptime": 123456,
  "timestamp": 1234567890,
  "source": "slave"
}
```

### 3. 测试命令 (test)
用于测试系统连接和功能。

#### 发送格式
```json
{
  "type": "test",
  "timestamp": 1234567890,
  "source": "master"
}
```

#### 响应格式
```json
{
  "type": "test_response",
  "result": true,
  "timestamp": 1234567890,
  "source": "slave",
  "sensor_value": 512
}
```

### 4. 心跳消息 (heartbeat)
用于维持连接状态和监控系统运行。

#### 发送格式
```json
{
  "type": "heartbeat",
  "timestamp": 1234567890,
  "source": "master",
  "command_count": 25
}
```

#### 响应格式
```json
{
  "type": "heartbeat",
  "timestamp": 1234567890,
  "source": "slave",
  "system_ready": true,
  "execution_count": 15,
  "uptime": 123456
}
```

### 5. 初始化命令 (init)
用于系统初始化和版本确认。

#### 发送格式
```json
{
  "type": "init",
  "timestamp": 1234567890,
  "source": "master",
  "version": "1.0"
}
```

#### 响应格式
```json
{
  "type": "init_response",
  "timestamp": 1234567890,
  "source": "slave",
  "version": "1.0",
  "system_ready": true
}
```

### 6. 错误消息 (error)
用于报告错误和异常情况。

#### 发送格式
```json
{
  "type": "error",
  "error": "JSON解析失败",
  "timestamp": 1234567890,
  "source": "slave"
}
```

## 控制目标说明

### 1. 继电器控制 (relay)
- **目标**: "relay"
- **值**: 0=关闭, 1=开启
- **引脚**: 数字引脚4
- **功能**: 控制继电器开关

### 2. LED控制 (led)
- **目标**: "led"
- **值**: 0=关闭, 1=开启
- **引脚**: 数字引脚13
- **功能**: 控制LED指示灯

### 3. 电机控制 (motor)
- **目标**: "motor"
- **值**: 0-255 (PWM值)
- **引脚**: 数字引脚5
- **功能**: 控制电机速度

### 4. 传感器读取 (sensor)
- **目标**: "sensor"
- **值**: 任意值 (忽略)
- **引脚**: 模拟引脚A0
- **功能**: 读取传感器数值

## 通信流程

### 1. 系统初始化流程
```
主控制器 → 初始化命令 → ESP32模块1 → WiFi/蓝牙 → ESP32模块2 → 从控制器
主控制器 ← 初始化响应 ← ESP32模块1 ← WiFi/蓝牙 ← ESP32模块2 ← 从控制器
```

### 2. 控制命令流程
```
主控制器 → 控制命令 → ESP32模块1 → WiFi/蓝牙 → ESP32模块2 → 从控制器
主控制器 ← 控制响应 ← ESP32模块1 ← WiFi/蓝牙 ← ESP32模块2 ← 从控制器
```

### 3. 状态查询流程
```
主控制器 → 状态请求 → ESP32模块1 → WiFi/蓝牙 → ESP32模块2 → 从控制器
主控制器 ← 状态响应 ← ESP32模块1 ← WiFi/蓝牙 ← ESP32模块2 ← 从控制器
```

## 错误处理

### 1. JSON解析错误
当收到无效的JSON格式时，发送错误响应：
```json
{
  "type": "error",
  "error": "JSON解析失败",
  "timestamp": 1234567890,
  "source": "slave"
}
```

### 2. 未知命令类型
当收到未知的命令类型时，发送错误响应：
```json
{
  "type": "error",
  "error": "未知命令类型: unknown_type",
  "timestamp": 1234567890,
  "source": "slave"
}
```

### 3. 控制目标错误
当收到未知的控制目标时，发送错误响应：
```json
{
  "type": "error",
  "error": "未知控制目标: unknown_target",
  "timestamp": 1234567890,
  "source": "slave"
}
```

## 超时处理

### 1. 命令超时
- 主控制器发送命令后，等待响应超时时间：5秒
- 超时后重新发送命令，最多重试3次

### 2. 心跳超时
- 心跳间隔：10秒
- 心跳超时时间：30秒
- 超时后认为连接断开，尝试重新连接

## 数据验证

### 1. 时间戳验证
- 时间戳必须是有效的毫秒数
- 时间戳不能超过当前时间+1小时
- 时间戳不能早于系统启动时间

### 2. 控制值验证
- 继电器和LED：值必须为0或1
- 电机：值必须在0-255范围内
- 传感器：值被忽略

### 3. 消息来源验证
- 主控制器消息来源必须为"master"
- 从控制器消息来源必须为"slave"
- ESP32模块消息来源必须为"bridge"

## 扩展协议

### 1. 添加新的控制目标
在从控制器代码中添加新的控制逻辑：
```cpp
else if (target == "new_device") {
    // 新设备控制逻辑
    digitalWrite(NEW_DEVICE_PIN, value > 0 ? HIGH : LOW);
    success = true;
}
```

### 2. 添加新的消息类型
在消息处理函数中添加新的消息类型：
```cpp
else if (type == "new_message") {
    handleNewMessage(doc);
}
```

### 3. 添加新的响应字段
在响应JSON中添加新的字段：
```json
{
  "type": "status_response",
  "system_ready": true,
  "execution_count": 15,
  "new_field": "new_value",
  "timestamp": 1234567890,
  "source": "slave"
}
```

## 安全考虑

### 1. 消息验证
- 验证消息格式和字段类型
- 检查时间戳的合理性
- 验证消息来源

### 2. 错误处理
- 捕获所有可能的异常
- 发送详细的错误信息
- 记录错误日志

### 3. 连接安全
- 使用心跳机制监控连接状态
- 实现自动重连机制
- 防止消息丢失和重复

## 性能优化

### 1. 消息大小
- 控制JSON消息大小在512字节以内
- 避免发送不必要的数据
- 使用压缩算法（如需要）

### 2. 响应时间
- 控制命令响应时间应在100ms以内
- 状态查询响应时间应在50ms以内
- 测试命令响应时间应在200ms以内

### 3. 内存使用
- 使用动态JSON文档
- 及时释放内存
- 避免内存泄漏
