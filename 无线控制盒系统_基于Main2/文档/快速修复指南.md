# 无线通信快速修复指南

## 问题诊断

### 当前问题
- 433MHz通信模块连接到引脚18和1
- 引脚18与编码器5（CLK5）和硬件中断5冲突
- 引脚1与硬件串口TX冲突
- 代码中使用引脚24和25，与硬件连接不匹配
- **新增问题**：编码器值变化时没有发送数据
- **新增问题**：波特率配置问题（433MHz模块9600，串口监视器115200）
- **新增问题**：发射接收一体模块配置问题

### 解决方案
**新的引脚配置：使用引脚28和29**

## 修复步骤

### 1. 硬件连接修改

#### 433MHz模块接线
```
433MHz模块    →    Arduino引脚
VCC          →    5V
GND          →    GND
TXD          →    引脚29（发送）
RXD          →    引脚28（接收）
```

**重要：** 请将433MHz模块的TXD连接到Arduino的引脚29，RXD连接到引脚28

### 2. 软件配置更新

#### 主控制器（Main_Wireless_Master.ino）
```cpp
// 无线通信相关 - 使用SoftwareSerial
// 修改引脚配置，避免与编码器、LED和硬件串口冲突
// 使用引脚28和29，这些引脚完全空闲，不会与任何现有功能冲突
// 注意：需要将433MHz模块的TXD连接到Arduino的引脚29，RXD连接到引脚28
SoftwareSerial wirelessSerial(28, 29); // RX=28, TX=29

// 编码器值变化检测变量
int lastEcCnt[5] = {0, 0, 0, 0, 0};
unsigned long lastEncoderSendTime = 0;
const unsigned long ENCODER_SEND_INTERVAL = 200; // 200ms发送间隔
```

#### 无线控制盒（WirelessControlBox.ino）
```cpp
// 无线通信相关 - 使用SoftwareSerial
// 修改引脚配置，避免与编码器、LED和硬件串口冲突
// 使用引脚28和29，这些引脚完全空闲，不会与任何现有功能冲突
// 注意：需要将433MHz模块的TXD连接到Arduino的引脚29，RXD连接到引脚28
SoftwareSerial wirelessSerial(28, 29); // RX=28, TX=29

// 编码器值变化检测变量
int lastEcCnt[5] = {0, 0, 0, 0, 0};
unsigned long lastEncoderSendTime = 0;
const unsigned long ENCODER_SEND_INTERVAL = 200; // 200ms发送间隔
```

### 3. 波特率说明

#### 波特率配置
- **433MHz模块**：9600波特率（SoftwareSerial）
- **串口监视器**：115200波特率（调试输出）
- **两者独立**：串口监视器波特率不影响433MHz通信

#### 为什么串口监视器波特率不影响通信？
```cpp
// 433MHz模块使用独立的SoftwareSerial
SoftwareSerial wirelessSerial(28, 29); // 9600波特率
wirelessSerial.begin(9600);

// 串口监视器使用硬件Serial
Serial.begin(115200); // 115200波特率，仅用于调试
```

### 4. 发射接收一体模块说明

#### 模块特点
- **双向通信**：每个模块都可以发送和接收
- **自动切换**：发送时自动切换到发射模式，接收时自动切换到接收模式
- **无需手动切换**：模块会自动处理发送/接收状态

#### 通信流程
```
主控制器                   无线控制盒
    |                         |
    |-- 发送数据 -->          |
    |                         |-- 接收数据
    |                         |
    |<-- 发送数据 --          |
    |-- 接收数据              |
```

### 5. 新增功能：编码器数据自动发送

#### 编码器值变化检测和发送
```cpp
// 检查编码器值变化并发送数据
void checkAndSendEncoderChanges()
{
  unsigned long currentTime = millis();
  
  // 检查是否到了发送间隔时间
  if (currentTime - lastEncoderSendTime < ENCODER_SEND_INTERVAL) {
    return;
  }
  
  // 检查每个编码器的值是否发生变化
  bool hasChanges = false;
  for (int i = 0; i < 5; i++) {
    if (ecCnt[i] != lastEcCnt[i]) {
      hasChanges = true;
      break;
    }
  }
  
  // 如果有变化且已配对，发送编码器数据
  if (hasChanges && Val.isPaired) {
    for (int i = 0; i < 5; i++) {
      if (ecCnt[i] != lastEcCnt[i]) {
        // 发送编码器数据
        sendWirelessData(0x20 + i, ecCnt[i] & 0xFF, 0x00);
        Serial.print("发送编码器");
        Serial.print(i);
        Serial.print("数据: ");
        Serial.println(ecCnt[i]);
        
        // 更新上次发送的值
        lastEcCnt[i] = ecCnt[i];
      }
    }
    lastEncoderSendTime = currentTime;
  }
}
```

#### 在BtLoop函数中调用
```cpp
void BtLoop(void)
{
  static unsigned long _pre_time = 0;
  unsigned long _time = millis();
  if (_time - _pre_time >= 100) //10ms更新一次
  {
    // ... 现有代码 ...
    
    // 检查编码器值变化并发送数据
    checkAndSendEncoderChanges();
  }
}
```

### 6. 测试程序

#### 主控制器测试程序（WirelessTest_Master.ino）
```cpp
/*
 * 主控制器无线通信测试程序
 * 用于验证433MHz通信和配对功能
 * 引脚配置：RX=28, TX=29
 */

#include <SoftwareSerial.h>

// 无线通信引脚配置
SoftwareSerial wirelessSerial(28, 29); // RX=28, TX=29

// 测试变量
unsigned long lastHeartbeat = 0;
const unsigned long HEARTBEAT_INTERVAL = 2000; // 2秒心跳
bool isPaired = false;

void setup() {
  // 初始化串口通信（调试用）
  Serial.begin(115200);
  Serial.println("=== 主控制器无线通信测试 ===");
  
  // 初始化无线通信（433MHz模块）
  wirelessSerial.begin(9600);
  Serial.println("无线串口初始化完成");
  Serial.println("RX=28, TX=29");
  Serial.println("433MHz模块波特率: 9600");
  Serial.println("串口监视器波特率: 115200");
  
  // 发送配对请求
  sendPairingRequest();
}

void loop() {
  // 处理接收到的数据
  if (wirelessSerial.available()) {
    processReceivedData();
  }
  
  // 定期发送心跳包
  if (millis() - lastHeartbeat > HEARTBEAT_INTERVAL) {
    sendHeartbeat();
    lastHeartbeat = millis();
  }
  
  delay(100);
}

// 发送配对请求
void sendPairingRequest() {
  byte pairingData[] = {0xFD, 0x0E, 0x00, 0x00, 0x00, 0x00, 0xDF};
  wirelessSerial.write(pairingData, 7);
  Serial.println("发送配对请求: FD 0E 00 00 0000 DF");
}

// 发送心跳包
void sendHeartbeat() {
  byte heartbeatData[] = {0xFD, 0x30, 0x00, 0x00, 0x00, 0x00, 0xDF};
  wirelessSerial.write(heartbeatData, 7);
  Serial.println("发送心跳包: FD 30 00 00 0000 DF");
}

// 处理接收到的数据
void processReceivedData() {
  byte data[7];
  int bytesRead = 0;
  
  // 读取数据
  while (wirelessSerial.available() && bytesRead < 7) {
    data[bytesRead] = wirelessSerial.read();
    bytesRead++;
  }
  
  // 检查数据格式
  if (bytesRead == 7 && data[0] == 0xFD && data[6] == 0xDF) {
    Serial.print("接收到数据: ");
    for (int i = 0; i < 7; i++) {
      Serial.print(data[i], HEX);
      Serial.print(" ");
    }
    Serial.println();
    
    // 处理配对确认
    if (data[1] == 0x0F) {
      isPaired = true;
      Serial.println("配对成功！");
    }
  }
}
```

#### 无线控制盒测试程序（WirelessTest_ControlBox.ino）
```cpp
/*
 * 无线控制盒通信测试程序
 * 用于验证433MHz通信和配对功能
 * 引脚配置：RX=28, TX=29
 */

#include <SoftwareSerial.h>

// 无线通信引脚配置
SoftwareSerial wirelessSerial(28, 29); // RX=28, TX=29

// 测试变量
unsigned long lastHeartbeat = 0;
const unsigned long HEARTBEAT_INTERVAL = 2000; // 2秒心跳
bool isPaired = false;

void setup() {
  // 初始化串口通信（调试用）
  Serial.begin(115200);
  Serial.println("=== 无线控制盒通信测试 ===");
  
  // 初始化无线通信（433MHz模块）
  wirelessSerial.begin(9600);
  Serial.println("无线串口初始化完成");
  Serial.println("RX=28, TX=29");
  Serial.println("433MHz模块波特率: 9600");
  Serial.println("串口监视器波特率: 115200");
}

void loop() {
  // 处理接收到的数据
  if (wirelessSerial.available()) {
    processReceivedData();
  }
  
  // 定期发送心跳包
  if (millis() - lastHeartbeat > HEARTBEAT_INTERVAL) {
    sendHeartbeat();
    lastHeartbeat = millis();
  }
  
  delay(100);
}

// 发送配对确认
void sendPairingConfirm() {
  byte pairingData[] = {0xFD, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xDF};
  wirelessSerial.write(pairingData, 7);
  Serial.println("发送配对确认: FD 0F 00 00 0000 DF");
}

// 发送心跳包
void sendHeartbeat() {
  byte heartbeatData[] = {0xFD, 0x30, 0x00, 0x00, 0x00, 0x00, 0xDF};
  wirelessSerial.write(heartbeatData, 7);
  Serial.println("发送心跳包: FD 30 00 00 0000 DF");
}

// 处理接收到的数据
void processReceivedData() {
  byte data[7];
  int bytesRead = 0;
  
  // 读取数据
  while (wirelessSerial.available() && bytesRead < 7) {
    data[bytesRead] = wirelessSerial.read();
    bytesRead++;
  }
  
  // 检查数据格式
  if (bytesRead == 7 && data[0] == 0xFD && data[6] == 0xDF) {
    Serial.print("接收到数据: ");
    for (int i = 0; i < 7; i++) {
      Serial.print(data[i], HEX);
      Serial.print(" ");
    }
    Serial.println();
    
    // 处理配对请求
    if (data[1] == 0x0E) {
      Serial.println("收到配对请求，发送确认...");
      sendPairingConfirm();
      isPaired = true;
    }
    
    // 处理心跳包
    if (data[1] == 0x30) {
      Serial.println("收到心跳包");
    }
  }
}
```

### 7. 测试步骤

#### 步骤1：硬件连接
1. **断开电源**
2. **修改连接**：
   - 将433MHz模块的TXD连接到Arduino的引脚29
   - 将433MHz模块的RXD连接到Arduino的引脚28
3. **重新接通电源**

#### 步骤2：软件更新
1. **上传主控制器代码**：`Main_Wireless_Master.ino`
2. **上传无线控制盒代码**：`WirelessControlBox.ino`
3. **打开串口监视器**：波特率设置为115200

#### 步骤3：测试验证
1. **基本通信测试**：
   - 观察串口输出，确认"无线串口初始化完成"
   - 检查是否能看到配对请求和心跳包

2. **配对测试**：
   - 主控制器自动发送配对请求
   - 无线控制盒收到请求后发送确认
   - 确认配对成功

3. **编码器数据测试**：
   - 旋转编码器旋钮
   - 观察串口输出，确认看到"发送编码器X数据: XXX"
   - 检查接收端是否收到编码器数据

### 8. 故障排除

#### 问题1：串口无输出
- 检查Arduino板是否正确连接
- 确认串口监视器波特率设置为115200
- 检查USB连接是否正常

#### 问题2：无线通信失败
- 检查433MHz模块接线是否正确
- 确认引脚28和29连接正确
- 检查模块电源是否正常

#### 问题3：配对失败
- 确认两个设备都已启动
- 检查是否有其他433MHz设备干扰
- 尝试重新启动设备

#### 问题4：编码器数据不发送
- 确认设备已配对成功
- 检查编码器值是否真的发生变化
- 查看串口输出是否有错误信息

#### 问题5：波特率问题
- **433MHz模块**：9600波特率（自动配置）
- **串口监视器**：115200波特率（调试输出）
- **两者独立**：不会相互影响

### 9. 成功标准

- ✅ 串口监视器显示"无线串口初始化完成"
- ✅ 能看到配对请求和确认消息
- ✅ 能看到定期的心跳包
- ✅ 两个设备能够相互通信
- ✅ **新增**：旋转编码器时能看到数据发送消息

## 注意事项

1. **引脚冲突**：新的引脚配置（28,29）避免了所有已知的引脚冲突
2. **硬件连接**：确保433MHz模块的TXD连接到Arduino的引脚29，RXD连接到引脚28
3. **测试顺序**：先测试基本通信，再测试配对功能，最后测试编码器数据发送
4. **环境干扰**：避免在有其他433MHz设备的环境中测试
5. **编码器数据**：编码器值变化时会自动发送数据，发送间隔为200ms
6. **波特率**：433MHz模块9600，串口监视器115200，两者独立工作
7. **发射接收一体**：模块会自动处理发送/接收状态，无需手动切换

## 联系支持

如果按照本指南操作后仍然无法解决问题，请：
1. 检查硬件连接是否正确
2. 确认代码已正确上传
3. 查看串口监视器的详细错误信息
4. 联系技术支持并提供详细的错误信息
