# 指示灯和串口调试说明

## 指示灯说明

### 1. 系统指示灯类型

#### 1.1 数码管显示屏
- **位置**：控制盒面板上的数码管
- **功能**：显示系统参数和状态
- **数量**：3个数码管（led1, led2, led3）
- **引脚定义**：
  - `led1`：DIO=36, RCLK=34, SCLK=32
  - `led2`：DIO=26, RCLK=24, SCLK=22  
  - `led3`：DIO=46, RCLK=44, SCLK=42

#### 1.2 板载LED指示灯
- **位置**：Arduino板上的内置LED（LED_BUILTIN）
- **功能**：配对状态指示
- **状态**：
  - **常亮**：配对成功
  - **熄灭**：配对失败或未配对

#### 1.3 433MHz模块指示灯
- **位置**：433MHz发射接收模块上的LED
- **功能**：无线通信状态指示
- **状态**：
  - **闪烁**：正在发送或接收数据
  - **常亮**：模块工作正常
  - **熄灭**：模块未工作或故障

### 2. 配对状态指示方案

#### 2.1 使用板载LED指示配对状态

##### 主控制器LED指示代码
```cpp
// 在主控制器中添加LED指示函数
void updatePairingLED() {
  if (Val.wirelessConnected) {
    digitalWrite(LED_BUILTIN, HIGH);  // 配对成功，LED常亮
  } else {
    digitalWrite(LED_BUILTIN, LOW);   // 配对失败，LED熄灭
  }
}

// 在loop()函数中调用
void loop() {
  // ... 其他代码 ...
  updatePairingLED();
}
```

##### 无线控制盒LED指示代码
```cpp
// 在无线控制盒中添加LED指示函数
void updatePairingLED() {
  if (Val.isPaired && Val.wirelessConnected) {
    digitalWrite(LED_BUILTIN, HIGH);  // 配对成功，LED常亮
  } else {
    digitalWrite(LED_BUILTIN, LOW);   // 配对失败，LED熄灭
  }
}

// 在loop()函数中调用
void loop() {
  // ... 其他代码 ...
  updatePairingLED();
}
```

#### 2.2 使用数码管显示配对状态

##### 主控制器数码管显示
```cpp
// 在LedShow()函数中添加配对状态显示
void LedShow(void) {
  // ... 原有代码 ...
  
  // 显示配对状态
  if (Val.wirelessConnected) {
    sprintf(ledBuf, "PAIR");
    led1.ledShow(ledBuf);
  } else {
    sprintf(ledBuf, "WAIT");
    led1.ledShow(ledBuf);
  }
}
```

##### 无线控制盒数码管显示
```cpp
// 在LedShow()函数中添加配对状态显示
void LedShow(void) {
  // ... 原有代码 ...
  
  // 显示配对状态
  if (Val.isPaired && Val.wirelessConnected) {
    sprintf(ledBuf, "OK");
    led1.ledShow(ledBuf);
  } else if (Val.isPaired) {
    sprintf(ledBuf, "CONN");
    led1.ledShow(ledBuf);
  } else {
    sprintf(ledBuf, "PAIR");
    led1.ledShow(ledBuf);
  }
}
```

## 串口调试说明

### 1. 串口连接选择

#### 1.1 调试建议
- **主控制器**：连接主控制器的串口进行调试
- **无线控制盒**：连接无线控制盒的串口进行调试
- **同时调试**：可以同时连接两个设备的串口进行对比调试

#### 1.2 串口参数设置
- **波特率**：115200
- **数据位**：8
- **停止位**：1
- **校验位**：无

### 2. 串口调试信息

#### 2.1 主控制器串口输出
```
无线通信初始化完成
设备ID: 1
收到配对请求
配对确认已发送
状态数据已发送给无线控制盒
配对状态：已连接
```

#### 2.2 无线控制盒串口输出
```
无线通信初始化完成
设备ID: 2
发送配对请求
配对成功！
收到无线命令: 0x01000001
配对状态：已配对且已连接
```

### 3. 调试步骤

#### 3.1 硬件连接
1. **主控制器**：
   - 连接USB线到电脑
   - 打开Arduino IDE
   - 选择正确的端口和板型

2. **无线控制盒**：
   - 连接USB线到电脑
   - 打开Arduino IDE
   - 选择正确的端口和板型

#### 3.2 软件调试
1. **上传代码**：
   - 分别上传主控制器和无线控制盒代码
   - 确保代码编译无错误

2. **打开串口监视器**：
   - 波特率设置为115200
   - 观察串口输出信息

3. **测试配对**：
   - 观察配对过程
   - 检查配对状态信息

### 4. 常见调试问题

#### 4.1 串口无输出
**可能原因**：
- 串口连接错误
- 波特率设置错误
- 代码未正确上传

**解决方案**：
1. 检查USB连接
2. 确认波特率设置
3. 重新上传代码

#### 4.2 配对失败
**可能原因**：
- 433MHz模块连接错误
- 设备距离过远
- 代码逻辑问题

**解决方案**：
1. 检查模块连接
2. 缩短设备距离
3. 查看串口错误信息

### 5. 调试工具推荐

#### 5.1 Arduino IDE串口监视器
- **优点**：简单易用，集成度高
- **缺点**：功能有限

#### 5.2 第三方串口工具
- **PuTTY**：功能强大，支持多种协议
- **串口调试助手**：界面友好，功能丰富
- **Tera Term**：免费开源，功能完善

### 6. 调试技巧

#### 6.1 分步调试
1. **硬件测试**：先测试硬件连接
2. **基础功能**：测试基本功能
3. **无线通信**：测试无线通信
4. **配对功能**：测试配对功能

#### 6.2 日志记录
```cpp
// 添加详细的调试日志
void debugLog(const char* message) {
  unsigned long currentTime = millis();
  Serial.print("[");
  Serial.print(currentTime);
  Serial.print("] ");
  Serial.println(message);
}

// 使用示例
debugLog("配对请求已发送");
debugLog("收到配对确认");
```

#### 6.3 状态监控
```cpp
// 定期输出系统状态
void printSystemStatus() {
  static unsigned long lastPrint = 0;
  unsigned long currentTime = millis();
  
  if (currentTime - lastPrint >= 5000) {  // 每5秒打印一次
    Serial.println("=== 系统状态 ===");
    Serial.print("配对状态: ");
    Serial.println(Val.wirelessConnected ? "已连接" : "未连接");
    Serial.print("最后通信: ");
    Serial.print((currentTime - Val.lastWirelessCommand) / 1000);
    Serial.println("秒前");
    Serial.println("================");
    lastPrint = currentTime;
  }
}
```

## 总结

### 指示灯选择建议
1. **板载LED**：简单可靠，适合快速判断配对状态
2. **数码管显示**：信息丰富，适合显示详细状态
3. **433MHz模块LED**：专业指示，适合硬件调试

### 串口调试建议
1. **主控制器优先**：建议先调试主控制器
2. **同时调试**：可以同时连接两个设备进行对比
3. **详细日志**：添加详细的调试日志信息
4. **定期监控**：定期输出系统状态信息

### 调试流程
1. **硬件检查**：确认所有连接正确
2. **代码上传**：确保代码正确上传
3. **串口监控**：观察串口输出信息
4. **功能测试**：测试各项功能
5. **问题排查**：根据错误信息进行排查
